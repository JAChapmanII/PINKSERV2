
template<int O> void MarkovModel<O>::increment( // {{{
		std::queue<std::string> chain, std::string target, unsigned count) {
	// if there are two many words in the prefix, pop them off
	while(chain.size() > this->m_order)
		chain.pop();

	// determine the start point id
	unsigned v = global::dictionary[""];
	if(chain.size() == this->m_order)
		v = dictionary[chain.front()];

	// insert the chain in the appropriate lower order model
	this->m_model[v].increment(chain, target, count);
} // }}}
template<int O> std::string MarkovModel<O>::random(std::queue<std::string> chain) { // {{{
	// if there are two many words in the prefix, pop them off
	while(chain.size() > this->m_order)
		chain.pop();

	// determine the start point id
	unsigned v = dictionary[""];
	if(chain.size() == this->m_order)
		v = dictionary[chain.front()];

	// fetch random from the appropriate lower order model
	return this->m_model[v].random(chain);
} // }}}
template<int O> bool MarkovModel<O>::contains(std::queue<std::string> chain) { // {{{
	// if there are two many words in the prefix, pop them off
	while(chain.size() > this->m_order)
		chain.pop();

	// determine the start point id
	unsigned v = dictionary[""];
	if(chain.size() == this->m_order)
		v = dictionary[chain.front()];

	// if we haven't seen this seed at this level, we can't see it below
	if(!util::contains(this->m_model, v))
		return false;

	// find out if the lower order model has seen this seed
	return this->m_model[v].contains(chain);
} // }}}
template<int O> unsigned MarkovModel<O>::operator[](std::queue<std::string> chain) { // {{{
	// if there are two many words in the prefix, pop them off
	while(chain.size() > this->m_order)
		chain.pop();

	// determine the start point id
	unsigned v = dictionary[""];
	if(chain.size() == this->m_order)
		v = dictionary[chain.front()];

	// fetch value from the appropriate lower order model
	return this->m_model[v][chain];
} // }}}
template<int O> MarkovModel<O - 1> MarkovModel<O>::operator[](std::string word) { // {{{
	return this->m_model[dictionary[word]];
} // }}}
template<int O> unsigned MarkovModel<O>::size() const { // {{{
	return this->m_model.size();
} // }}}
template<int O> ostream &MarkovModel<O>::write(ostream &out) { // {{{
	unsigned s = this->m_model.size();
	brain::write(out, s);
	for(auto i : this->m_model) {
		unsigned f = i.first;
		brain::write(out, f);
		i.second.write(out);
	}
	return out;
} // }}}
template<int O> istream &MarkovModel<O>::read(istream &in) { // {{{
	unsigned s = 0;
	brain::read(in, s);
	for(unsigned i = 0; i < s; ++i) {
		unsigned key;
		MarkovModel<O - 1> value;
		brain::read(in, key);
		value.read(in);
		this->m_model[key] = value;
	}
	return in;
} // }}}
template<int O> std::map<unsigned, unsigned> MarkovModel<O>::endpoint( // {{{
		std::queue<std::string> chain) {
	// if there are two many words in the prefix, pop them off
	while(chain.size() > this->m_order)
		chain.pop();

	// determine the start point id
	unsigned v = dictionary[""];
	if(chain.size() == this->m_order)
		v = dictionary[chain.front()];

	// fetch value from the appropriate lower order model
	return this->m_model[v].endpoint(chain);
} // }}}
template<int O> unsigned MarkovModel<O>::total(std::queue<std::string> chain) { // {{{
	// if there are two many words in the prefix, pop them off
	while(chain.size() > this->m_order)
		chain.pop();

	// determine the start point id
	unsigned v = dictionary[""];
	if(chain.size() == this->m_order)
		v = dictionary[chain.front()];

	// fetch value from the appropriate lower order model
	return this->m_model[v].total(chain);
} // }}}


void MarkovModel<0>::increment( // {{{
		std::queue<std::string> chain, std::string target, unsigned count) {
	this->m_model[dictionary[target]] += count;
	this->m_total += count;
} // }}}
std::string MarkovModel<0>::random(std::queue<std::string> chain) { // {{{
	if(this->m_total == 0) {
		std::cerr << "this std::map is empty!?" << std::endl;
		return "";
	}
	uniform_int_distribution<> uid(1, this->m_total);
	unsigned target = uid(global::rengine);
	auto i = this->m_model.begin();
	for(; (i != this->m_model.end()) && (target > i->second); ++i)
		target -= i->second;
	if(i == this->m_model.end()) {
		std::cerr << "fell off the bandwagon" << endl;
		std::cerr << "total: " << this->m_total << endl;
		return "";
	}
	unsigned word = i->first;
	return dictionary[word];
} // }}}
bool MarkovModel<0>::contains(std::queue<std::string> chain) { // {{{
	if(chain.empty())
		return false;
	return util::contains(this->m_model, dictionary[chain.back()]);
} // }}}
unsigned MarkovModel<0>::operator[](std::queue<std::string> chain) { // {{{
	if(chain.empty())
		return 0;
	return this->m_model[dictionary[chain.back()]];
} // }}}
unsigned MarkovModel<0>::size() const { // {{{
	return this->m_model.size();
} // }}}
ostream &MarkovModel<0>::write(ostream &out) { // {{{
	return brain::write(out, this->m_model);
} // }}}
istream &MarkovModel<0>::read(istream &in) { // {{{
	brain::read(in, this->m_model);
	for(auto i : this->m_model)
		this->m_total += i.second;
	return in;
} // }}}
std::map<unsigned, unsigned> MarkovModel<0>::endpoint(std::queue<std::string> chain) { // {{{
	return this->m_model;
} // }}}
unsigned MarkovModel<0>::total(std::queue<std::string> chain) { // {{{
	return this->m_total;
} // }}}

// vim: ft=cpp:
