#include "global.hpp"
#include "util.hpp"
#include "brain.hpp"

// TODO: temp for debugging
#include <iostream>

template<int O> void MarkovModel<O>::increment( // {{{
		std::queue<std::string> chain, std::string target, unsigned count) {
	// if there are two many words in the prefix, pop them off
	while(chain.size() > this->m_order)
		chain.pop();

	// determine the start point id
	unsigned v = global::dictionary[""];
	if(chain.size() == this->m_order)
		v = global::dictionary[chain.front()];

	// insert the chain in the appropriate lower order model
	this->m_model[v].increment(chain, target, count);
} // }}}
template<int O> std::string MarkovModel<O>::random(std::queue<std::string> chain) { // {{{
	// if there are two many words in the prefix, pop them off
	while(chain.size() > this->m_order)
		chain.pop();

	// determine the start point id
	unsigned v = global::dictionary[""];
	if(chain.size() == this->m_order)
		v = global::dictionary[chain.front()];

	// fetch random from the appropriate lower order model
	return this->m_model[v].random(chain);
} // }}}
template<int O> bool MarkovModel<O>::contains(std::queue<std::string> chain) { // {{{
	// if there are two many words in the prefix, pop them off
	while(chain.size() > this->m_order)
		chain.pop();

	// determine the start point id
	unsigned v = global::dictionary[""];
	if(chain.size() == this->m_order)
		v = global::dictionary[chain.front()];

	// if we haven't seen this seed at this level, we can't see it below
	if(!util::contains(this->m_model, v))
		return false;

	// find out if the lower order model has seen this seed
	return this->m_model[v].contains(chain);
} // }}}
template<int O> unsigned MarkovModel<O>::operator[](std::queue<std::string> chain) { // {{{
	// if there are two many words in the prefix, pop them off
	while(chain.size() > this->m_order)
		chain.pop();

	// determine the start point id
	unsigned v = global::dictionary[""];
	if(chain.size() == this->m_order)
		v = global::dictionary[chain.front()];

	// fetch value from the appropriate lower order model
	return this->m_model[v][chain];
} // }}}
template<int O> MarkovModel<O - 1> MarkovModel<O>::operator[](std::string word) { // {{{
	return this->m_model[global::dictionary[word]];
} // }}}
template<int O> unsigned MarkovModel<O>::size() const { // {{{
	return this->m_model.size();
} // }}}
template<int O> std::ostream &MarkovModel<O>::write(std::ostream &out) { // {{{
	unsigned s = this->m_model.size();
	brain::write(out, s);
	for(auto i : this->m_model) {
		unsigned f = i.first;
		brain::write(out, f);
		i.second.write(out);
	}
	return out;
} // }}}
template<int O> std::istream &MarkovModel<O>::read(std::istream &in) { // {{{
	unsigned s = 0;
	brain::read(in, s);
	for(unsigned i = 0; i < s; ++i) {
		unsigned key;
		MarkovModel<O - 1> value;
		brain::read(in, key);
		value.read(in);
		this->m_model[key] = value;
	}
	return in;
} // }}}
template<int O> std::map<unsigned, unsigned> MarkovModel<O>::endpoint( // {{{
		std::queue<std::string> chain) {
	// if there are two many words in the prefix, pop them off
	while(chain.size() > this->m_order)
		chain.pop();

	// determine the start point id
	unsigned v = global::dictionary[""];
	if(chain.size() == this->m_order)
		v = global::dictionary[chain.front()];

	// fetch value from the appropriate lower order model
	return this->m_model[v].endpoint(chain);
} // }}}
template<int O> unsigned MarkovModel<O>::total(std::queue<std::string> chain) { // {{{
	// if there are two many words in the prefix, pop them off
	while(chain.size() > this->m_order)
		chain.pop();

	// determine the start point id
	unsigned v = global::dictionary[""];
	if(chain.size() == this->m_order)
		v = global::dictionary[chain.front()];

	// fetch value from the appropriate lower order model
	return this->m_model[v].total(chain);
} // }}}

// vim: ft=cpp:
