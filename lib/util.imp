#include <sstream>

template<typename T> T util::split(std::string str, std::string on) { // {{{
	T fields;
	// there are no separators
	if(str.find_first_of(on) == std::string::npos) {
		fields.push_back(str);
		return fields;
	}
	size_t fsep = 0;
	while((fsep = str.find_first_of(on)) != std::string::npos) {
		fields.push(str.substr(0, fsep));
		str = str.substr(fsep + 1);
	}
	if(!str.empty())
		fields.push(str);
	return fields;
} // }}}
template<typename T> std::string util::join(T strs, std::string with) { // {{{
	if(strs.empty())
		return "";
	std::string res;
	while(!strs.empty()) {
		res += strs.front() + with;
		strs.pop();
	}
	return res.substr(0, res.length() - with.length());
} // }}}

template<typename T, typename F>
		std::vector<T> util::filter(std::vector<T> vec, F func) {
	std::vector<T> res;
	for(auto i : vec)
		if(func(i))
			res.push_back(i);
	return res;
}

template<typename T> T util::fromString(std::string str) {
	std::stringstream ss(str);
	T result;
	ss >> result;
	return result;
}
template<typename T> std::string util::asString(T val) {
	std::stringstream ss;
	ss << val;
	return ss.str();
}

template<typename T> bool
		util::contains(std::vector<T> vec, T val) { // {{{
	return (find(vec.begin(), vec.end(), val) != vec.end());
} // }}}
template<typename K, typename V> bool
		util::contains(std::map<K, V> map, K key) { // {{{
	return (map.find(key) != map.end());
} // }}}
template<typename K, typename V>
		bool util::contains(std::vector<std::pair<K, V>> list, K key) { // {{{
	for(auto i : list)
		if(i.first == key)
			return true;
	return false;
} // }}}

// vim: ft=cpp:
